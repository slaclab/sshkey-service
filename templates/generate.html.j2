<!DOCTYPE html>
<html>
<head>
    <title>{{ title }}</title>
    <style>
        .d-none {
            display: none;
        }
        .errmsg {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>{{ username }}</h1>
    <p>{{ message }}</p>

    <p>This page provides instructions for generating a new SSH keypair for use with S3DF. Specifically, we present shell commands that you should paste into your local (eg laptop) terminal that will create a SSH private and public keypair. You will then be able to utilize this keypair to SSH into S3DF without having to always enter a username, password and 2factor (duo).</p>
    
    <p>Our implementation also considers the use of time-limited SSH keys, so the generated keypair is only valid for a limited time period. This is currently set to a maximum of 7 days. For further security, you will also need to <a href="/list/{{ username }}">refresh</a> your keys at least every 25 hours for the keypair to be valid.</p>
    <p>You may generate as may keypairs as you like and on as many computers as you like. However, you must register each public key with our service before you can use it to access S3DF.</p>

    <p>To create a new key, please enter the below commands on the computer terminal:</p>

    <pre><code>

# setup the local directories for the keypairs
mkdir -p {{ prefix_path }} && chmod 700 {{ prefix_path }}

# generate a new keypair
ssh-keygen -t {{ key_type }} -f {{ prefix_path }}/temp-key -C "{{ username }}"
# determine the SHA256 fingerprint and move the key to the correct location
fingerprint=$(ssh-keygen -lf {{ prefix_path }}/temp-key | cut -f2 -d' ' | sed 's|[/+]|.|g')
mv {{ prefix_path }}/temp-key {{ prefix_path }}/${fingerprint}
# perhaps just delete this?
mv {{ prefix_path }}/temp-key.pub {{ prefix_path }}/${fingerprint}.pub

# remove any old keypairs that are probably expired
find {{ prefix_path }} -type f -name 'SHA256:*' ! -name '*.pub' -print0 -atime +14 # -delete

# configure your local ssh configuration to include the s3df config
grep -q "Include {{ prefix_path }}/s3df.conf" ~/.ssh/config || echo -e "Include {{ prefix_path }}/s3df.conf\n\n$(< ~/.ssh/config)" > ~/.ssh/config

# add s3df ssh dropin config to utilize the private key when ssh'ing into S3DF
cat > {{ prefix_path }}/s3df.conf << EOF
Host sdfssh001 sdfssh001.slac.stanford.edu sdfssh001.sdf.slac.stanford.edu sdfssh002 sdfssh002.slac.stanford.edu sdfssh002.sdf.slac.stanford.edu s3dflogin-mfa.slac.stanford.edu
$(find {{ prefix_path }} -type f -name 'SHA256:*' ! -name '*.pub' -print0 | xargs -0 -n1 echo '    IdentityFile ')
EOF

echo
echo

# determine the public key for your newly minted keypair - this must be uploaded to our servers so that you can use this keypair to access S3DF
ssh-keygen -e -f {{ prefix_path }}/${fingerprint}


    </code></pre>

    <p>The output from the previous set of commands provides the ssh public key that we can use to identify you on our servers when you use the associated private key to ssh into our systems.</p>
    <p>Please enter this public key into the following form so that it may be registered.</p>

    <form id="uploadpublickey" action="javascript:void(0);">
        <textarea name="public_key" rows="6" cols=78" placeholder='---- BEGIN SSH2 PUBLIC KEY ----&#10;Comment: "256-bit ED25519, ...&#10;AAAABBBCCCDDDEEEFFFGGGHHH&#10;---- END SSH2 PUBLIC KEY ----'></textarea><br>
        <button class="submitbtn">Submit</button>
        <p class="d-none errmsg"></p>
    </form>

<script type="text/javascript">
    const clearerr = () => {
        const vmsg = document.querySelector("#uploadpublickey p.errmsg");
        vmsg.innerHTML = ``;
        vmsg.classList.add("d-none");
    }

    const errmsg = (msg) => {
        const vmsg = document.querySelector("#uploadpublickey p.errmsg");
        vmsg.innerHTML = msg;
        vmsg.classList.remove("d-none");
    }

    const postPutJSON = function(serverURL, method, thedocument, onCompletion, errormsg) {
        async function checkHTTPResponse(resp) {
            if(!resp.ok) {
                console.log("Call to ", serverURL, " failed");
                let respdata = await resp.text(); 
                return Promise.reject(new Error(resp.statusText + " --> " + respdata));
            }
        return resp.json();
    }

    function checkStatus(status) {
        console.log(status); 
        onCompletion(); 
        return true; 
    }

    fetch(serverURL, { method: method, headers: { "Content-Type": "application/json" }, body: JSON.stringify(thedocument) })
        .then(checkHTTPResponse)
        .then(checkStatus)
        .catch((msg) => { errormsg(msg) })
    }


    document.querySelector("#uploadpublickey .submitbtn").addEventListener("click", (ev) => {
        clearerr();
        const publickey = document.querySelector("#uploadpublickey textarea[name='public_key']").value;
        if(publickey.length <= 10) {
            errmsg(`Valid public keys cannot be empty strings or less than x characters long`);
            return false;
        }
        if(publickey.toLowerCase().includes("private key")) {
            errmsg(`Please don't paste the private key here`);
            return false;
        }
        if(!publickey.toLowerCase().includes("public key")) {
            errmsg(`Valid public keys typically include a comment string to indicate that this is a public key`);
            return false;
        }

        const theDocument = {
            public_key: publickey
        };

        postPutJSON("/upload/{{ username }}", "POST", theDocument, () => { window.location = "/list/{{ username }}";}, errmsg);
    });

</script>

</html>
